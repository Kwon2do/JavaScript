# 생성자 함수에 의한 객체 생성

지금까지는 **객체 리터럴 '{}'** 을 사용해서 객체를 생성했음.

객체 리터럴을 사용하는 것이 아닌, **생성자 함수**를 사용하여 객체를 생성하는 방법을 학습한다.

## Object 생성자 함수

> **생성자 함수란?**<br>
> new 연산자와 함께 호출하여 객체를 생성하는 함수<br>
> **생성자 함수로 만들어진 객체**를 **`인스턴스`** 라고 함.

```javascript
const student = new Object();
student.ID = 2020;
student.sayHello = () => {
  console.log("ID:" + this.ID);
};
student.sayHello(); //ID:2020
```

## 객체 리터럴 vs 생성자 함수

### 객체 리터럴

`장점`<br>

- 직관적이고, 간편하다

`단점`<br>

- 하나의 리터럴당 하나의 객체밖에 생성하지 못하기 때문에 비효율적이다.

### 생성자 함수

`장점`<br>

- 여러 개의 객체(인스턴스)를 찍어낼 수 있다.

```javascript
function Circle(radius) {
  //생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킨다.
  this.radius = radius;
  this.getDiameter = () => {
    return 2 * this.radius;
  };
}

const circle1 = new Circle(5);
console.log(circle1.getDiameter()); // 10
```

위 처럼, 하나의 템플릿(클래스)을 만들어놓으면 똑같은 구조의 객체를 여러 개 만드는 것은 매우 간단한 일이 된다.

> **this 알아보기**<br>
>
> - 일반 함수로서 호출 -> **전역 객체**
> - 메서드로서 호출 -> **메서드를 호출한 객체**
> - 생성자 함수로서 호출 -> **미래에 생성할 인스턴스**

자바(클래스 기반 객체지향 언어)의 클래스 작성이랑 동작은 유사하다.(하지만, 형식X)

1. **일반 함수**처럼 작성
2. **new 연산자** 사용
3. **생성자 함수**로 동작함

---

## JS 인스턴스 생성 및 초기화 원리

1. 암묵적으로 **빈 객체를 생성**한다.
2. 생성한 빈 객체(인스턴스)가 **this에 바인딩**된다. (생성자 함수 body 실행 전에)

```javascript
function Circle(radius) {
// 여기서 암묵적으로 인스턴스가 생성되고, this에 바인딩 됨.
console.log(this); // Circle {}

this.radius = radius;
...
}
```

3. this에 바인딩 되었기 때문에 이를 이용해서 인스턴스를 초기화해줄 수 있다.

4. 모든 처리가 끝나면, this를 암묵적으로 반환.<br>만약, return문을 사용하면 return문에 명시한 값 혹은 객체를 반환한다.<br>
   그러나, 이는 **생성자 함수의 기본 동작을 훼손**하기 때문에 **`생성자 함수 내부에서는 return문을 반드시 생략`** 해야 한다.

---

## 내부 메서드 Call, Construct

JS에서 **함수도 (특수한)객체**다.<br>
즉, 객체가 가지고 있는 내부 슷롯과 내부 메서드를 모두 가지고 있다.<br>
**일반 객체는 호출 불가**하지만, **함수는 호출이 가능**하다.

일반 함수로 호출되었을 때<br>
=> **내부메서드 [[Call]]** 호출

new 연산자와 함께 호출되었을 때<br>
=> **내부메서드 [[Construct]]** 호출

**모든 함수 객체는 호출 가능**하지만,
**모든 함수 객체를 생성자 함수로 호출할 수 있는 것은 아니다**.

### 생성자 함수로 호출 가능한 함수 객체(constructor)와 그렇지 않은 함수 객체(non-constructor)

- constructor : 함수 선언문, 함수 표현식, 클래스

```JAVASCRIPT
//함수 선언문
function foo() {}
//함수 표현식
const bar = function() {};
```

- non-constructor : 메서드(ES6메서드축약표현), 화살표 함수

> **`정리`**<br>
> new + 일반 함수 => 생성자 함수 호출<br>
> 내부 메서드 Construct 호출<br><br>
> 일반함수 => 일반함수 호출<br>
> 내부 메서드 Call 호출

---

## new.target(ES6 문법)

**`파스칼 케이스 컨벤션`**<br>
생성자 함수로 작성한건데, new 연산자 없이 호출되는 것을 방지하기 위함.

new.target은 **new 연산자와 함께 함수가 호출되었을 때만** 함수 자신을 존재한다.
(그렇지 않으면, undefined)

> **스코프 세이프 생성자 패턴**<br> > `this instanceof 함수명`을 사용해서 생성자함수와 연결되어 있는지 확인할 수 있다.
